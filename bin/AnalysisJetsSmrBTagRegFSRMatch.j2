/**
 * @author Fabio Zoratti <fabio.zoratti96@gmail.com> <fabio.zoratti@desy.de> <fabio.zoratti@cern.ch>
 * @date 30/7/2018
 * @file AnalysisJetsSmrBTagRegFSRMatch.cc
 * First apply smearing to data, then apply scale factors to correct MC for btag, then uses regression algorithm to correct energy and then corrects for final state radiation.
 * At the end I check the number of correct higgs matches for the first 2 jets.
 */

/**
 * DOCS: select the value for the global variable correction_level and build.
 * Also set the other global variable debug to false.
 */




#include <string>
#include <iostream>
#include <fstream>
#include <vector>
#include <array>
#include <tuple>
#include <cmath>

#include "TTree.h"
#include "TFile.h"
#include "TH1.h"
#include "TLorentzVector.h"
#include "TMath.h"
#include "TCanvas.h"
#include "TRandom3.h"
#include "TChain.h"

#include "JetMETCorrections/Modules/interface/JetResolution.h"
#include "Analysis/Tools/interface/BTagCalibrationStandalone.h"



using std::cout;
using std::string;
using std::endl;
using std::array;
using std::cerr;
using std::vector;

{% if not bkg %}
enum class CorrectionLevel { nothing, only_smearing, smearing_btag, \
                             smearing_btag_regression, smearing_btag_regression_fsr };
{% else %}
enum class CorrectionLevel { nothing, regression, regression_fsr };
{% endif %}
namespace Smearing {
  enum class method {scaling, stochastic};
}

enum class Match {
  higgsd,
  spectator,
  other,
  no_match
};


const Float_t rcone(0.4);
const unsigned int kLen = 100;
const Float_t deepcsv_cut_tight = 0.4941;
const Float_t deepcsv_cut_loose = 0.1522;
const Float_t b_tagging_efficiency = 0.99;
const Int_t kTight = 2;
const array<Float_t, 3> pt_cut_had{ {100, 100, 40} };
const array<Float_t, 3> pt_cut_lep{ {40, 40, 30} };
const array<Float_t, 3> eta_cut{ {2.2, 2.2, 2.2} };
const Float_t lepton_in_jet_pt_cut = 12;
const bool debug = false;
const bool corrections_after = true;

const CorrectionLevel correction_level = CorrectionLevel::{{ cl }};
const bool apply_trigger_cut = {{ trig }};
const UInt_t highx = {{ highx }};
const UInt_t bins = {{ bins }};
const Float_t soft_jet_distance = 0.8;
const Int_t pdgBId = 5;
const Int_t pdgCId = 4;
const Int_t heavyHiggs = 36;
const Float_t gen_part_deltarcut = 0.3;
const Int_t kPuId = 4;
const Int_t kTrigobj_jet_id = 1;
const Float_t kTrigobj_pt_had = 100;
const Float_t kTrigobj_pt_lep = 40;
const Float_t kTrigobj_eta = 2.3;
const Float_t kTrigobj_deltaRmin = 0.3;
const Int_t kTrigobj_id_had_jet = 580;
const Int_t kTrigobj_id_lep_jet = 530;
const Int_t kTrigobj_filter_bits = 3;


bool check_distance_enough(const TLorentzVector &a, const TLorentzVector &b) {
  if (debug) {
    cout << "Delta R: " << a.DeltaR(b) << endl;
    cout << "Eta bw 4vec: " << TMath::Abs(a.Eta() - b.Eta()) << endl;
  }
  return a.DeltaR(b) > 1;
}


                                              
std::ostream& operator<<(std::ostream& os, const Match& m) {
  switch (m) {
  case Match::higgsd:
    return os << "higgs daughter";
    break;
  case Match::spectator:
    return os << "spectator";
    break;
  case Match::other:
    return os << "other";
    break;
  case Match::no_match:
    return os << "no match";
    break;
  default:
    throw std::runtime_error("Trying to print a non declared kind of Match");
    return os;
    break;
  }
  return os;
}




class Jet : public TLorentzVector {
 public:
  Jet(const TLorentzVector& a, UInt_t i) : TLorentzVector(a) {
    orig_index_ = i;
  }
  UInt_t Idx() const { return orig_index_; }
  Match GetMatch() const { return match_; }
  void SetMatch(const Match m) { match_ = m; }
  
 private:
  Match match_;
  UInt_t orig_index_;
};


class DataContainer {
 public:
  
  DataContainer();
  int SetTreeBranches(TTree* tree);
  void CreateTree(TTree* tree);
  bool get_real_pt(Int_t index, Float_t* pt);
  void fill_histogram(TTree*, std::vector<TH1F*>, TTree*);
  void initialize_current_data(UInt_t i);
  void sort_by_Pt();
  Smearing::method smearing(const TVector3& jet, const TVector3& genjet, \
                            const Float_t& radius, Float_t* realpt) const;
  
  /**
   * @brief Applies the smearing to the pt
   * MC data is better than the real one, so MC data have to been smeared.
   * The new pt is stored in current_jet_pt_[index]
   */
  void smear_current_data(UInt_t index);

  /**
   * @brief Other scale factors for the MC with btagging
   * The new pt is always current_jet_pt_[index]
   */
  void apply_btag_sf();

  /**
   * @brief Applied the new regression algorithm that improves jet energy
   * resolution for events with leptons. In fact it is a scale factor on the pt
   */
  void apply_jet_reg_sf(UInt_t index);

  /**
   * @brief Looks for all jets with btag_deep > deepcsv_cut_tight and checks if there are
   * very close light flavour jets. If yes, it adds the closest TLorentzVector of the
   * soft jet to the original one. (which is saved in corrected_jet[i])
   */
  void apply_fsr_correction();
  
  /**
   * @brief Reads lev and decides what corrections have to be applied on pt
   */
  void apply_all_corrections(CorrectionLevel lev);

  /**
   * @brief Matches GenPart from GenJet from Jet to check whether if
   * the Jet is a Higgs daughter or not. It checks the idx corrected_jet
   * and saves the result in the corrected_jet
   */
  void match_jet_with_part(Jet& jet);


  /**
   * @brief Recursive function that looks at the origin of the genpart i.
   * It will stop when it encounters a higgs or something that is not a b-flavour jet
   */
  Match match_genpart(UInt_t i);

  /**
   * Checks whether if there is a trigger object matching the jet.
   * It will also check that the trigObj as at least kTrigobj_pt and other requirements
   * on eta. To be matched it will check from the selected TrigObj the one with least deltaR
   * It will reject the match if it is further than kTrigobj_deltaRmin
   * @returns The index of matched trigObj. -1 if no is found and trigger is not fired. -2 if trigger is fired but no particle found.
   */
  Int_t match_trigger_object(Bool_t leptonic, const Jet& jet);



  /**
   * Returns the idx_th cut for the pt for both leptonic and non leptonic cases
   */
  inline Float_t right_pt_cut(Bool_t leptonic, UInt_t idx) {
    return leptonic ? pt_cut_lep[idx] : pt_cut_had[idx];
  }

  inline Float_t smaller_pt_cut(UInt_t idx) {
    return (pt_cut_lep[idx] < pt_cut_had[idx]) ? pt_cut_lep[idx] : pt_cut_had[idx];
  }
  
  inline Bool_t compare_with_right_deepcsv(UInt_t idx{% if bkg %}, UInt_t btagged{% endif %}) {
    {% if bkg %}
    return (btagged < 2) ? btag_deep_[idx] > deepcsv_cut_tight  \
      : btag_deep_[idx] < deepcsv_cut_loose;
    {% else %}
    return (btag_deep_[idx] > deepcsv_cut_tight);
    {% endif %}
  }

  
 private:
  JME::JetResolution resolution;
  JME::JetResolutionScaleFactor resolution_sf;
  BTagCalibration calib;
  BTagCalibrationReader reader;
  vector<Jet> corrected_jet;
  Float_t weigth;
  
  // Data from tree
  UInt_t run_;
  ULong64_t event_;
  UInt_t lumisection_;
  UInt_t njet_;
  Float_t jet_pt_[kLen];
  Float_t jet_eta_[kLen];
  Float_t jet_phi_[kLen];
  Float_t jet_mass_[kLen];
  Int_t jet_id_[kLen];
  Float_t btag_deep_[kLen];
  Float_t jet_b_reg_corr[kLen];
  Int_t jet_n_electrons[kLen];
  Int_t jet_n_muons[kLen];
  {% if not bkg %}
  Int_t jet_genjet_idx_[kLen];
  UInt_t n_gen_jet_;
  Float_t genjet_pt_[kLen];
  Float_t genjet_eta_[kLen];
  Float_t genjet_phi_[kLen];
  {% endif %}
  Bool_t trigger_path_had;
  Bool_t trigger_path_lep;
  {% if not bkg %}
  UInt_t ngenpart_;
  Int_t genjet_parton_flavour_[kLen];
  Int_t genpart_genpart_idxmother_[kLen];
  Float_t genpart_pt_[kLen];
  Float_t genpart_eta_[kLen];
  Float_t genpart_phi_[kLen];
  Float_t genpart_mass_[kLen];
  Int_t genpart_pdgid_[kLen];
  {% endif %}
  Float_t jet_b_reg_res_[kLen];
  Int_t jet_puId_[kLen];
  // 
  Int_t jet_electron_idx1[kLen];
  UInt_t n_electron;
  Float_t electron_pt_[kLen];
  Float_t electron_eta_[kLen];
  Float_t electron_phi_[kLen];
  Int_t jet_muon_idx1[kLen];
  UInt_t n_muon;
  Float_t muon_pt_[kLen];
  Float_t muon_eta_[kLen];
  Float_t muon_phi_[kLen];
  Bool_t muon_medium_id_[kLen];
  UInt_t n_trig_obj_;
  Int_t trig_obj_id_[kLen];
  Float_t trig_obj_pt_[kLen];
  Float_t trig_obj_eta_[kLen];
  Float_t trig_obj_phi_[kLen];
  Float_t trig_obj_l1pt_[kLen];
  Float_t trig_obj_l2pt_[kLen];
  Int_t trig_obj_filter_bits_[kLen];
  Float_t rho_jec_;
  
  // Extra values to put in the new tree
  Float_t mass_;
  Float_t new_pt_[kLen];
  Float_t new_eta_[kLen];
  Float_t new_phi_[kLen];
  Float_t new_mass_[kLen];
  Bool_t leptonic;
  {% if not bkg %}
  UInt_t matches_;
  Bool_t first_bjet_matched;
  Bool_t second_bjet_matched;
  /**
   * This variable is used to see if the corrected_jets are not in the same
   * order as the original ones. If this array is for example [1, 3, 2] means
   * that the corrected jet #1 was in first position, the corrected_jet #2 was
   * in third position and the corrected_jet #3 was in second position.
   */
  UInt_t reordering_[kLen];
  {% endif %}
};

/**
 * @brief Constructor that opens btag scalefactor file.
 */
DataContainer::DataContainer() : resolution("tables/Fall17_25nsV1_MC_PtResolution_AK4PFchs.txt"), \
                                 resolution_sf("tables/Fall17_25nsV1_MC_SF_AK4PFchs.txt") , \
                                 calib("deepcsv", "tables/DeepCSV_94XSF_V3_B_F.csv"), \
                                 reader(&calib, BTagEntry::OP_MEDIUM) {}


void DataContainer::sort_by_Pt() {
  std::sort(corrected_jet.begin(), corrected_jet.end(), \
            [](const TLorentzVector&a, const TLorentzVector& b) {
              return a.Pt() > b.Pt();
            });
}

/**
 * @brief Smears MC pt to simulate real data
 * See https://twiki.cern.ch/twiki/bin/viewauth/CMS/JetResolution
 */
Smearing::method DataContainer::smearing(const TVector3& jet, const TVector3& genjet, \
              const Float_t& radius, Float_t* realpt) const {
  JME::JetParameters parameters;
  parameters.setJetPt(jet.Pt());
  parameters.setJetEta(jet.Eta());
  parameters.setRho(rho_jec_);
  Float_t sigmajer = resolution.getResolution(parameters);
  Float_t sjer = resolution_sf.getScaleFactor(parameters);
  if ((2*jet.DeltaR(genjet) < radius) && \
      (TMath::Abs(jet.Pt() - genjet.Pt()) < 3*sigmajer*jet.Pt())) {
    Float_t cjer = 1 + (sjer - 1)*(jet.Pt() - genjet.Pt())/jet.Pt();
    if (cjer < 0) {
      cjer = 0;
    }
    *realpt = jet.Pt()*cjer;
    if (debug) {
      cout << "Smearing scaling: cjer " << cjer << endl;
      cout << "Old pt: " << jet.Pt() << "\tnew pt: " << *realpt << endl;
    }
    return Smearing::method::scaling;
  } else {
    TRandom3 generator;
    Float_t cjer = 1 + generator.Gaus(0, sigmajer) * \
      TMath::Sqrt(TMath::Max(sjer*sjer - 1, Float_t(0)));
    *realpt = jet.Pt()*cjer;
    if (debug) {
      cout << "Smearing stochastic: cjer " << cjer << endl;
      cout << "Old pt: " << jet.Pt() << "\tnew pt: " << *realpt << endl;
    }
    return Smearing::method::stochastic;
  }
}



int DataContainer::SetTreeBranches(TTree * t) {
  // Event Info
  t->SetBranchAddress("event", &event_);
  t->SetBranchAddress("run", &run_);
  t->SetBranchAddress("luminosityBlock", &lumisection_);
  // gen jets
  t->SetBranchAddress("nJet", &njet_);
  t->SetBranchAddress("Jet_pt", jet_pt_);
  t->SetBranchAddress("Jet_eta", jet_eta_);
  t->SetBranchAddress("Jet_phi", jet_phi_);
  t->SetBranchAddress("Jet_mass", jet_mass_);
  t->SetBranchAddress("Jet_jetId", jet_id_);
  t->SetBranchAddress("Jet_btagDeepB", btag_deep_);
  t->SetBranchAddress("Jet_bRegCorr", jet_b_reg_corr);
  t->SetBranchAddress("Jet_nElectrons", &jet_n_electrons);
  t->SetBranchAddress("Jet_nMuons", &jet_n_muons);
  {% if not bkg %}
  t->SetBranchAddress("Jet_genJetIdx", jet_genjet_idx_);
  t->SetBranchAddress("nGenJet", &n_gen_jet_);
  t->SetBranchAddress("GenJet_pt", genjet_pt_);
  t->SetBranchAddress("GenJet_eta", genjet_eta_);
  t->SetBranchAddress("GenJet_phi", genjet_phi_);
  {% endif %}
  t->SetBranchAddress("Jet_bRegRes", jet_b_reg_res_);
  t->SetBranchAddress("HLT_DoublePFJets100MaxDeta1p6_DoubleCaloBTagCSV_p33", &trigger_path_had);
  t->SetBranchAddress("HLT_Mu12_DoublePFJets40MaxDeta1p6_DoubleCaloBTagCSV_p33", &trigger_path_lep);
  {% if not bkg %}
  t->SetBranchAddress("nGenPart", &ngenpart_);
  t->SetBranchAddress("GenJet_partonFlavour", genjet_parton_flavour_);
  t->SetBranchAddress("GenPart_genPartIdxMother", genpart_genpart_idxmother_);
  t->SetBranchAddress("GenPart_pt", genpart_pt_);
  t->SetBranchAddress("GenPart_eta", genpart_eta_);
  t->SetBranchAddress("GenPart_phi", genpart_phi_);
  t->SetBranchAddress("GenPart_mass", genpart_mass_);
  t->SetBranchAddress("GenPart_pdgId", genpart_pdgid_);
  {% endif %}
  t->SetBranchAddress("Jet_puId", jet_puId_);
  t->SetBranchAddress("Jet_electronIdx1", &jet_electron_idx1);
  t->SetBranchAddress("nElectron", &n_electron);
  t->SetBranchAddress("Electron_pt", electron_pt_);
  t->SetBranchAddress("Electron_eta", electron_eta_);
  t->SetBranchAddress("Electron_phi", electron_phi_);
  t->SetBranchAddress("Jet_muonIdx1", &jet_muon_idx1);
  t->SetBranchAddress("nMuon", &n_muon);
  t->SetBranchAddress("Muon_pt", muon_pt_);
  t->SetBranchAddress("Muon_eta", muon_eta_);
  t->SetBranchAddress("Muon_phi", muon_phi_);
  t->SetBranchAddress("Muon_mediumId", &muon_medium_id_);
  t->SetBranchAddress("nTrigObj", &n_trig_obj_);
  t->SetBranchAddress("TrigObj_id", trig_obj_id_);
  t->SetBranchAddress("TrigObj_pt", trig_obj_pt_);
  t->SetBranchAddress("TrigObj_eta", trig_obj_eta_);
  t->SetBranchAddress("TrigObj_phi", trig_obj_phi_);
  t->SetBranchAddress("TrigObj_l1pt", trig_obj_l1pt_);
  t->SetBranchAddress("TrigObj_l2pt", trig_obj_l2pt_);
  t->SetBranchAddress("fixedGridRhoFastjetAll", &rho_jec_);
  t->SetBranchAddress("TrigObj_filterBits", trig_obj_filter_bits_);
  return 0;
}



void DataContainer::CreateTree(TTree* t) {
  // Event Info
  t->Branch("event", &event_, "event/i");
  t->Branch("run", &run_, "run/l");
  t->Branch("luminosityBlock", &lumisection_, "luminosityBlock/i");
  // gen jets
  t->Branch("nJet", &njet_, "nJet/i");
  t->Branch("Jet_pt", jet_pt_, "Jet_pt[nJet]/F");
  t->Branch("Jet_eta", jet_eta_, "Jet_eta[nJet]/F");
  t->Branch("Jet_phi", jet_phi_, "Jet_phi[nJet]/F");
  t->Branch("Jet_mass", jet_mass_, "Jet_mass[nJet]/F");
  t->Branch("Jet_jetId", jet_id_, "Jet_jetId[nJet]/I");
  t->Branch("Jet_btagDeepB", btag_deep_, "Jet_btagDeepB[nJet]/F");
  t->Branch("Jet_bRegCorr", jet_b_reg_corr, "Jet_bRegCorr[nJet]/F");
  t->Branch("Jet_nElectrons", &jet_n_electrons, "Jet_nElectrons/I");
  t->Branch("Jet_nMuons", &jet_n_muons, "Jet_nMuons/F");
  {% if not bkg %}
  t->Branch("Jet_genJetIdx", jet_genjet_idx_, "Jet_genJetIdx[nJet]/I");
  t->Branch("nGenJet", &n_gen_jet_, "nGenJet/i");
  t->Branch("GenJet_pt", genjet_pt_, "GenJet_pt[nGenJet]/F");
  t->Branch("GenJet_eta", genjet_eta_, "GenJet_eta[nGenJet]/F");
  t->Branch("GenJet_phi", genjet_phi_, "GenJet_phi[nGenJet]/F");
  {% endif %}
  t->Branch("Jet_bRegRes", jet_b_reg_res_, "Jet_bRegRes[nJet]/F");
  t->Branch("HLT_DoublePFJets100MaxDeta1p6_DoubleCaloBTagCSV_p33", &trigger_path_had, \
            "HLT_DoublePFJets100MaxDeta1p6_DoubleCaloBTagCSV_p33/O");
  t->Branch("HLT_Mu12_DoublePFJets40MaxDeta1p6_DoubleCaloBTagCSV_p33", &trigger_path_lep,
            "HLT_Mu12_DoublePFJets40MaxDeta1p6_DoubleCaloBTagCSV_p33/O");
  {% if not bkg %}
  t->Branch("nGenPart", &ngenpart_, "nGenPart/i");
  t->Branch("GenJet_partonFlavour", genjet_parton_flavour_, "GenJet_partonFlavour[nGenJet]/I");
  t->Branch("GenPart_genPartIdxMother", genpart_genpart_idxmother_, "GenPart_genPartIdxMother[nGenPart]/i");
  t->Branch("GenPart_pt", genpart_pt_, "GenPart_pt[nGenPart]/F");
  t->Branch("GenPart_eta", genpart_eta_, "GenPart_eta[nGenPart]/F");
  t->Branch("GenPart_phi", genpart_phi_, "GenPart_phi[nGenPart]/F");
  t->Branch("GenPart_mass", genpart_mass_, "GenPart_mass[nGenPart]/F");
  t->Branch("GenPart_pdgId", genpart_pdgid_, "GenPart_pdgId[nGenPart]/F");
  {% endif %}
  t->Branch("Jet_puId", jet_puId_, "Jet_puId[nJet]/I");
  t->Branch("Jet_electronIdx1", jet_electron_idx1, "Jet_electronIdx1/I");
  t->Branch("nElectron", &n_electron, "nElectron/i");
  t->Branch("Electron_pt", electron_pt_, "Electron_pt[nElectron]/F");
  t->Branch("Electron_eta", electron_eta_, "Electron_eta[nElectron]/F");
  t->Branch("Electron_phi", electron_phi_, "Electron_phi[nElectron]/F");
  t->Branch("Jet_muonIdx1", jet_muon_idx1, "Jet_muonIdx1[nElectron]/I");
  t->Branch("nMuon", &n_muon, "nMuon/i");
  t->Branch("Muon_pt", muon_pt_, "Muon_pt[nMuon]/F");
  t->Branch("Muon_eta", muon_eta_, "Muon_eta[nMuon]/F");
  t->Branch("Muon_phi", muon_phi_, "Muon_phi[nMuon]/F");
  t->Branch("Muon_mediumId", &muon_medium_id_, "Muon_mediumId[nMuon]/O");
  t->Branch("Leptonic_event", &leptonic, "Leptonic_event/O");
  t->Branch("nTrigObj", &n_trig_obj_, "nTrigObj/i");
  t->Branch("TrigObj_id", trig_obj_id_, "TrigObj_id[nTrigObj]/F");
  t->Branch("TrigObj_pt", trig_obj_pt_, "TrigObj_pt[nTrigObj]/F");
  t->Branch("TrigObj_eta", trig_obj_eta_, "TrigObj_eta[nTrigObj]/F");
  t->Branch("TrigObj_phi", trig_obj_phi_, "TrigObj_phi[nTrigObj]/F");
  t->Branch("TrigObj_l1pt", trig_obj_l1pt_, "TrigObj_l1pt[nTrigObj]/F");
  t->Branch("TrigObj_l2pt", trig_obj_l2pt_, "TrigObj_l2pt[nTrigObj]/F");
  t->Branch("fixedGridRhoFastjetAll", &rho_jec_, "fixedGridRhoFastjetAll/F");
  t->Branch("TrigObj_filterBits", trig_obj_filter_bits_, "TrigObj_filterBits[nTrigObj]/I");

  // new data
  t->Branch("Mass", &mass_, "Mass/F");
  t->Branch("Jet_newPt", new_pt_, "Jet_newPt[nJet]/F");
  t->Branch("Jet_newEta", new_eta_, "Jet_newEta[nJet]/F");
  t->Branch("Jet_newPhi", new_phi_, "Jet_newPhi[nJet]/F");
  t->Branch("Jet_newMass", new_mass_, "Jet_newMass[nJet]/F");
  {% if not bkg %}
  t->Branch("nMatches", &matches_, "nMatches/i");
  t->Branch("Jet_newOriginalOrder", reordering_, "Jet_newOriginalOrder[nJet]/i");
  t->Branch("BjetMatched1", &first_bjet_matched, "BjetMatched1/O");
  t->Branch("BjetMatched2", &second_bjet_matched, "BjetMatched2/O");
  {% endif %}
}
// suggested regex
// t->SetBranchAddress(\"\([a-zA-Z_0-9]*\)\", \([&]*[a-zA-Z_0-9]*\));


{% if not bkg %}
/**
 * Modifies current_jet[i] smearing the pt.
 */
void DataContainer::smear_current_data(UInt_t i) {
  TVector3 genjet;
  Float_t appo;
  UInt_t j = corrected_jet[i].Idx();
  genjet.SetPtEtaPhi(genjet_pt_[j], genjet_eta_[j], genjet_phi_[j]);
  smearing(corrected_jet[i].Vect(), genjet, rcone, &appo);
  corrected_jet[i].SetPtEtaPhiM(appo, corrected_jet[i].Eta(),\
                              corrected_jet[i].Phi(), corrected_jet[i].M());
  if (debug) {
    cout << "smeared value: "  << appo << endl;
  }
}
{% endif %}

void DataContainer::apply_all_corrections(CorrectionLevel lev) {
  if (!corrections_after) {
    for (unsigned int i = 0; i < njet_; i++) {
      initialize_current_data(i);
    }
  }
  switch (lev) {
  case CorrectionLevel::nothing: break;
    {% if bkg %}
  case CorrectionLevel::regression:
    for (unsigned int i = 0; i < njet_; i++) {
      apply_jet_reg_sf(i);
    }
    sort_by_Pt();
    break;
  case CorrectionLevel::regression_fsr:
    for (unsigned int i = 0; i < njet_; i++) {
      apply_jet_reg_sf(i);
    }
    sort_by_Pt();
    apply_fsr_correction();
    sort_by_Pt();
    break;
    {% else %}
  case CorrectionLevel::only_smearing:
    for (unsigned int i = 0; i < njet_; i++) {
      smear_current_data(i);
    }
    sort_by_Pt();
    break;
  case CorrectionLevel::smearing_btag:
    for (unsigned int i = 0; i < njet_; i++) {
      smear_current_data(i);
    }
    sort_by_Pt();
    apply_btag_sf();
    sort_by_Pt();
    break;
  case CorrectionLevel::smearing_btag_regression:
    for (unsigned int i = 0; i < njet_; i++) {
      smear_current_data(i);
    }
    sort_by_Pt();
    apply_btag_sf();
    sort_by_Pt();
    for (unsigned int i = 0; i < njet_; i++) {
      apply_jet_reg_sf(i);
    }
    sort_by_Pt();
    break;
  case CorrectionLevel::smearing_btag_regression_fsr:
    for (unsigned int i = 0; i < njet_; i++) {
      smear_current_data(i);
    }
    sort_by_Pt();
    apply_btag_sf();
    sort_by_Pt();
    for (unsigned int i = 0; i < njet_; i++) {
      apply_jet_reg_sf(i);
    }
    sort_by_Pt();
    apply_fsr_correction();
    sort_by_Pt();
    break;
    {% endif %}
  }
}


void DataContainer::initialize_current_data(UInt_t i) {
  TLorentzVector appo;
  appo.SetPtEtaPhiM(jet_pt_[i], jet_eta_[i], jet_phi_[i], jet_mass_[i]);
  Jet appo1(appo, i);
  corrected_jet.push_back(appo1);
}

/**
 * Deprecated
 */
bool DataContainer::get_real_pt(Int_t index, Float_t *pt) {
  if (jet_b_reg_corr[index] != 0) {
    *pt = jet_b_reg_corr[index] * jet_pt_[index];
    return true;
  } else {
    *pt = jet_pt_[index];
    return false;
  }
}



{% if not bkg %}
/* 
 * Loops over genpart with id equal to b or bbar and select the closest one
 * Then reconstructs the original particle
 */
void DataContainer::match_jet_with_part(Jet& jet) {
  unsigned int i = jet.Idx();
  if (TMath::Abs(genjet_parton_flavour_[i]) != pdgBId) {
    jet.SetMatch(Match::other);
    if (debug) {
      cout << "Current genjet is not of the right flavour." << \
        " A bit strange (not the flavour). Its flavour is " << \
        genjet_parton_flavour_[i] << endl;
    }
    return;
  }
  Float_t min_value = 1.;
  Float_t min_index = -1;
  for (UInt_t j = 0; j < ngenpart_; j++) {
    if (TMath::Abs(genpart_pdgid_[j]) != pdgBId) {
      continue;
    }
    TLorentzVector appo;
    appo.SetPtEtaPhiM(genpart_pt_[j], genpart_eta_[j], \
                      genpart_phi_[j], genpart_mass_[i]);
    Float_t dR = appo.DeltaR(jet);
    if (dR < min_value) {
      min_value = dR;
      min_index = j;
    }
  }
  if (min_value < gen_part_deltarcut) {
    if (debug) {
      cout << "Found matching genpart. Now I check its origin" << endl;
    }
    Match appo = match_genpart(min_index);
    jet.SetMatch(appo);
    if (debug) {
      cout << "Matched origin of genpart: this is origin:" << appo << endl;
    }
  } else {
    if (debug) {
      cout << "Not found any matching genpart." << endl;
    }
    jet.SetMatch(Match::no_match);
  }
}
{% endif %}

{% if not bkg %}
Match DataContainer::match_genpart(UInt_t i) {
  if (debug) {
    cout << "Mother index of genpart: " << genpart_genpart_idxmother_[i] \
         << "\t current pdgid: " << genpart_pdgid_[i] << endl;
  }
  if (genpart_genpart_idxmother_[i] == -1) {
    if (TMath::Abs(genpart_pdgid_[i]) == pdgBId) {
      return Match::spectator;
    } else if (TMath::Abs(genpart_pdgid_[i]) == heavyHiggs) {
      return Match::higgsd;
    } else {
      return Match::other;
    }
  } else {
    if (TMath::Abs(genpart_pdgid_[i]) == pdgBId){
      return match_genpart(genpart_genpart_idxmother_[i]);
    } else if (TMath::Abs(genpart_pdgid_[i]) == heavyHiggs) {
      return Match::higgsd;
    } else {
      return Match::no_match;
    }
  }
}
{% endif %}


void DataContainer::fill_histogram(TTree* tree, \
                                   std::vector<TH1F*> plots, TTree* out_tree) {
  ULong64_t how_many;
  if (debug) {
    how_many = 10000;
  } else {
    how_many = tree->GetEntries();
  }

  for (ULong64_t event = 0; event < how_many; event++) {
    tree->GetEntry(event);
    if ({% if bkg %}true{% else %}apply_trigger_cut{% endif %}) {
      if (debug) {
        cout << "Printing a lot of stuff for trigger for debug." << endl;
      }
      if (debug) {
        for (UInt_t i = 0; i < n_trig_obj_; i++) {
          cout << "Trigid: " << trig_obj_id_[i] << "\tTrigger path had: " << trigger_path_had \
               << "\ttrigger path lep: " << trigger_path_lep << endl;
        }
      }
      if (!trigger_path_lep && !trigger_path_had) {
        continue;
      }
    }
    weigth = 1;
    corrected_jet.clear();
    if (debug) {
      cout << "\033[0;33m\n\nNew event\033[0m" << endl;
      cout << "Run = " << run_ << " | Lumi Section = "          \
           << lumisection_ << " | Event = " << event_ << endl;
      cout << " number of gen jets from njet = " << njet_ << endl;
      // If we have less than 3 jets the event is not useful
      cout << "njets: " << njet_ << endl;
    }
    if (njet_ < 3) {
      continue;
    }

    if (corrections_after) {
      for (unsigned int i = 0; i < njet_; i++) {
        initialize_current_data(i);
      }
    } else {
      apply_all_corrections(correction_level);
    }

    // Now check btags
    unsigned int btaggati = 0;
    vector<Jet> bjets;
    leptonic = false;
    if (debug) {
      cout << "Starting btagging check" << endl;
    }
    for (auto it = corrected_jet.begin(); it < corrected_jet.end() && \
           btaggati < 3; it++) {
      if (debug) {
        cout << "pt before: " << jet_pt_[it->Idx()] << "\neta: " <<     \
          jet_eta_[it->Idx()] << "\tcurrent_jet_pt: " << it->Pt()       \
             << "\tcurrent_jet_eta_:" << it->Eta() << "\nid: " << jet_id_[it->Idx()] << \
          "\tjet_b_reg_correction: " << jet_b_reg_corr[it->Idx()] << "\tjetid: " \
             << jet_id_[it->Idx()] << "\tktight: " << kTight << "\tbitwise: " \
             << (jet_id_[it->Idx()] & kTight) << endl;
        cout << "btag_deep: " << btag_deep_[it->Idx()] <<               \
          "\tpt smeared corrected: " << it->Pt() << "\teta: " <<        \
          jet_eta_[it->Idx()] << "\tcurrent_jet_eta_: " <<              \
          it->Eta() << "\tjet_b_regcor: " << jet_b_reg_corr[it->Idx()] << endl;
        cout << "Pileup id: " << jet_puId_[it->Idx()] << endl;
      }
      // First i check if we are already with a too small pt.
      if (it->Pt() < right_pt_cut(false, 2) && it->Pt() < right_pt_cut(true, 2)) {
        break;
      }
      if ((jet_id_[it->Idx()] & kTight) == 0) {
        continue;
      }
      // Check for pileup and throw away jet (not event)
      if ((jet_puId_[it->Idx()] & kPuId) == 0) {
        continue;
      }

      if (jet_n_electrons[it->Idx()] != 0) {
        if (debug) {
          cout << "There is an electron. Checking for pt cut" << \
            electron_pt_[jet_electron_idx1[it->Idx()]] << endl;
          cout << "Electrons in event: " << jet_n_electrons[it->Idx()] << endl;
        }
        if (electron_pt_[jet_electron_idx1[it->Idx()]] < lepton_in_jet_pt_cut || \
            std::isnan(electron_pt_[jet_electron_idx1[it->Idx()]])) {
          if (debug) {
            cout << "Electron too low energetic. Skipping" << endl;
          }
          continue;
        }
        // We are rejecting all jets with one electron in the jet
        if (debug) {
          cout << "We are rejecting all jets with one electron." << endl;
        }
        continue;
        leptonic = true;  // this line is never executed
      }
      if (jet_n_muons[it->Idx()] != 0) {
        if (debug) {
          cout << "There is a muon. Checking for pt cut: " << muon_pt_[jet_muon_idx1[it->Idx()]] \
               << "\tI want a medium muon: " << muon_medium_id_[jet_muon_idx1[it->Idx()]] << endl;
          cout << "Muons in event: " << jet_n_muons[it->Idx()] << endl;
        }
        if (muon_pt_[jet_muon_idx1[it->Idx()]] < lepton_in_jet_pt_cut ||   \
            !(muon_medium_id_[jet_muon_idx1[it->Idx()]])) {
          if (debug) {
            cout << "Muon too low energetic or too bad. Skipping" << endl;
          }
          continue;
        }
        // the event is marked as leptonic only if there is a lepton in the
        // 2 leading jets
        if (btaggati < 2) {
          leptonic = true;
        }
      }
      // Look at pt only if it is btagged
      if (compare_with_right_deepcsv(it->Idx(){% if bkg %}, btaggati {% endif %})) {
        // cuts on eta and pt
        if (TMath::Abs(it->Eta()) > eta_cut[btaggati]) {
          continue;
        } else {
          if (it->Pt() < smaller_pt_cut(btaggati))
            continue;
        }
        btaggati++;
        bjets.push_back(*it);
      }
    }
    if (debug) {
      cout << "btagged (with bkg it can be misleading. Counter counts bbnb, so btagged = 3 " \
           << "means that there are bb nb): " << btaggati << endl;
    }
    if (btaggati < 3) {
      continue;
    }
    if (debug) {
      cout << "This event is marked as leptonic: " << leptonic \
           << " now i check for real pt cut" << endl;
    }
    Bool_t successs = true;
    for (UInt_t i = 0; i < 2; i++) {
      if (bjets[i].Pt() < right_pt_cut(leptonic, i)) {
        successs = false;
      }
    }
    if (!successs) {
      continue;
    }
    
    // At least one of the 2 trigger paths must be true. If the trigger_path does not
    // match the right type of the event we reject that.
    if (apply_trigger_cut) {
      if (!(trigger_path_had && trigger_path_lep)) {
        if (debug) {
          cout << "Not both triggers are active. Let's check " << \
            "if the right one is fired" << endl;
        }
        if (trigger_path_had && leptonic) {
          continue;
        }
        if (trigger_path_lep && (!leptonic)) {
          continue;
        }
      }
    }

    if (debug) {
      cout << "I check if the distance is enough" << endl;
    }
    // Now i check if the couples jets are distant enough
    bool success = true;
    for (auto it = bjets.begin(); it != bjets.end(); it++) {
      for (auto jt = it + 1; jt != bjets.end(); jt++) {
        if (!check_distance_enough(*it, *jt)) {
          success = false;
          break;
        }
      }
    }
    if (!success) { continue; }
    if (TMath::Abs(bjets[0].Eta() - bjets[1].Eta()) > 1.5) {
      continue;
    }
    if (debug) {
      cout << "Distance was enough" << endl;
    }

    {% if not bkg %}
    unsigned int matched = 0;
    for (unsigned int i = 0; i < 2; i++) {
      match_jet_with_part(bjets[i]);
      if (debug) {
        cout << "Jet matched as " << bjets[i].GetMatch() << endl;
      }
      if (bjets[i].GetMatch() == Match::higgsd) {
        matched++;
      }
    }
    if (debug) {
      cout << "Matched as higgs daughter " << matched << " jets" << endl;
    }
    {% endif %}

    if (apply_trigger_cut) {
      Int_t appo1, appo2;
      appo1 = match_trigger_object(leptonic, bjets[0]);
      appo2 = match_trigger_object(leptonic, bjets[1]);
      if (debug) {
        cout << "Matching trigg" << endl;
      }
      if (appo1 < 0 || appo2 < 0) {
        if (debug) {
          cout << "Trigger failed. Skipping event" << endl;
        }
        continue;
      }
      if (debug) {
        cout << "Trigger passed." << endl;
      }
      {% if not bkg %}
      first_bjet_matched = (appo1 != -2);
      second_bjet_matched = (appo2 != -2);
      {% endif %}
    }

    if (corrections_after) {
      apply_all_corrections(correction_level);
      for (auto it : corrected_jet) {
        if (it.Idx() == bjets[0].Idx()) {
          bjets[0] = it;
        }
        if (it.Idx() == bjets[1].Idx()) {
          bjets[1] = it;
        }
      }
    }
    
    {% if not bkg %}
    if (debug) {
      cout << "Weight before multiplication for 0.512: " << weigth << endl;
    }
    weigth *= 0.64; // this is 0.8**2, to simulate online btag efficiency
    {% endif %}
    mass_ = -(bjets[0] - bjets[1]).M();
    {% if not bkg %}
    matches_ = matched;
    {% endif %}
    for (unsigned int k = 0; k < corrected_jet.size(); k++) {
      new_pt_[k] = corrected_jet[k].Pt();
      new_eta_[k] = corrected_jet[k].Eta();
      new_phi_[k] = corrected_jet[k].Phi();
      new_mass_[k] = corrected_jet[k].M();
      {% if not bkg %}
      reordering_[k] = corrected_jet[k].Idx();
      {% endif %}
    }
    cout << "\033[0;32mFilling with m = " << mass_ << \
      " and pt = " << bjets[0].Pt() << ". Weigth of this event: " << weigth \
         << "\033[0m" << endl;
    {% if bkg %}
    if (debug) {
      cout << "Weigth should be 1 for every event in bkg study: " << weigth \
           << endl;
    }
    {% endif %}
    out_tree->Fill();

    {% if bkg %}
    if (!leptonic) {
      plots[0]->Fill(mass_, weigth);
      plots[2]->Fill(bjets[0].Pt(), weigth);
      plots[4]->Fill(jet_b_reg_res_[bjets[0].Idx()], weigth);
    } else {
      plots[1]->Fill(mass_, weigth);
      plots[3]->Fill(bjets[0].Pt(), weigth);
      plots[5]->Fill(jet_b_reg_res_[bjets[0].Idx()], weigth);
    }
    {% else %}
    if (leptonic) {
      plots[matched + 3]->Fill(mass_, weigth);
      plots[7]->Fill(bjets[0].Pt(), weigth);
      plots[9]->Fill(jet_b_reg_res_[bjets[0].Idx()], weigth);
    } else {
      plots[matched]->Fill(mass_, weigth);
      plots[6]->Fill(bjets[0].Pt(), weigth);
      plots[8]->Fill(jet_b_reg_res_[bjets[0].Idx()], weigth);
    }
    {% endif %}
  }
}

inline Float_t delta_R(const Float_t eta1, const Float_t phi1, \
                const Float_t eta2, const Float_t phi2) {
  return TMath::Sqrt(TMath::Power(eta1 - eta2, 2) + TMath::Power(phi1 - phi2, 2));
}


Int_t DataContainer::match_trigger_object(Bool_t leptonic, const Jet& jet) {

  Float_t deltaR_min = 100;
  Int_t idx = -1;
  bool trovato = false;
  Float_t pt_cut = leptonic ? kTrigobj_pt_lep : kTrigobj_pt_had;
  Int_t trig_id = leptonic ? kTrigobj_id_lep_jet : kTrigobj_id_had_jet;
  if (debug) {
    cout << "Trying to match trigger objects. Is this jet leptonic? " << \
      leptonic << endl;
  }
  for (UInt_t i = 0; i < n_trig_obj_; i++) {
    if (debug) {
      cout << "trig id: " << trig_obj_id_[i] << "\ttrig pt: " <<        \
        trig_obj_pt_[i] << "\ttrig eta: " << trig_obj_eta_[i] <<        \
        "\ttrig phi: " << trig_obj_phi_[i] << endl;
    }

    if (trig_obj_id_[i] != kTrigobj_jet_id) {
      continue;
    }
    if (trig_obj_pt_[i] < pt_cut) {
      continue;
    }
    if (TMath::Abs(trig_obj_eta_[i]) > kTrigobj_eta) {
      continue;
    }
    trovato = true;
    Float_t cdeltaR = delta_R(trig_obj_eta_[i], trig_obj_phi_[i],\
                              jet.Eta(), jet.Phi());
    if (debug) {
      cout << "DeltaR: " << cdeltaR << endl;
    }
    if (cdeltaR < deltaR_min) {
      deltaR_min = cdeltaR;
      idx = i;
    }
  }
  if (deltaR_min > kTrigobj_deltaRmin && trovato) {
    idx = -2;
  } else if (deltaR_min > kTrigobj_deltaRmin && !trovato) {
    idx = -1;
  }
  if (debug) {
    cout << "Exited from first loop. Found: (-1 means not found) " << idx << endl;
  }
  if (idx < 0) {
    return idx;
  }
  if (debug) {
    cout << "Checking level 1 trigger" << endl;
  }
  if (trig_obj_l1pt_[idx] < pt_cut) {
    if (debug) {
      cout << "L1 trig failed." << endl;
    }
    return -3;
  }  
  if (debug) {
    cout << "Checking level 2 trigger" << endl;
  }
  if (trig_obj_l2pt_[idx] < pt_cut) {
    if (debug) {
      cout << "L2 trig pt: " << trig_obj_l2pt_[idx] << endl;
      cout << "L2 trig failed." << endl;
    }
    return -4;
  }

  // now i check for full hadronic jet
  idx = -5;
  if (debug) {
    cout << "Checking for full hadronic jet" << endl;
  }

  deltaR_min = 100;
  for (UInt_t i = 0; i < n_trig_obj_; i++) {
    if (debug) {
      cout << "Trig full had. Id: " << trig_obj_id_[i] <<\
        "\t and filter_bits: " << trig_obj_filter_bits_[i] << endl;
    }
    if (trig_obj_id_[i] != trig_id || \
        trig_obj_filter_bits_[i] != kTrigobj_filter_bits) {
      continue;
    }
    Float_t cdeltaR = delta_R(trig_obj_eta_[i], trig_obj_phi_[i], \
                              jet.Eta(), jet.Phi());
    if (debug) {
      cout << "DeltaR: " << cdeltaR << endl;
    }
    if (cdeltaR < deltaR_min) {
      deltaR_min = cdeltaR;
      idx = i;
    }
  }
  if (deltaR_min > kTrigobj_deltaRmin) {
    idx = -5;
  }
  if (debug) {
    cout << "Found trig obj as full hadronic jet: (negative value means not found) " <<\
      idx << endl;
  }
  return idx;
}

{% if not bkg %}
void DataContainer::apply_btag_sf() {
  if (debug) {
    cout << "Using scale factors for btagging" << endl;
  }
  UInt_t btagged = 0;
  
  for (auto it = corrected_jet.begin(); it != corrected_jet.end() && btagged < 3; it++) {
    if (btag_deep_[it->Idx()] > deepcsv_cut_tight) {
      BTagEntry::JetFlavor flavour;
      if (TMath::Abs(genjet_parton_flavour_[it->Idx()]) == pdgBId) {
        flavour = BTagEntry::FLAV_B;
      } else if (TMath::Abs(genjet_parton_flavour_[it->Idx()]) == pdgCId) {
        flavour = BTagEntry::FLAV_C;
      } else {
        flavour = BTagEntry::FLAV_UDSG;
      }
      if (debug) {
        cout << "Btag sf. Jet marked as: (b=0, c=1, other=2)" << flavour << endl;
      }
      if (flavour != BTagEntry::FLAV_UDSG) {
        Double_t appo = reader.eval(flavour, it->Eta(), it->Pt(), 0);
        weigth *= appo;
        btagged++;
        if (debug) {
          cout << "Retrieved sf: " << appo << "\nWeigth after this step: " << \
            weigth << endl;
        }
      }
    }
  }  
}
{% endif %}


void DataContainer::apply_jet_reg_sf(UInt_t i) {
  if (jet_b_reg_corr[corrected_jet[i].Idx()] != 0) {
    corrected_jet[i].SetPtEtaPhiM(corrected_jet[i].Pt()*jet_b_reg_corr[corrected_jet[i].Idx()], \
                                  corrected_jet[i].Eta(), corrected_jet[i].Phi(), \
                                  corrected_jet[i].M());
  } else {
    cerr << "Something nasty is happening. jet_b_reg_correction is 0." << endl;
  }
}

void DataContainer::apply_fsr_correction() {
  std::vector<std::tuple<Jet, UInt_t>> bjets;
  std::vector<Jet> softjets;
  if (debug) {
    cout << "FSR\n\n" << endl;
  }
  if (njet_ < 4) {
    return;
  }
  for (UInt_t i = 0; i < njet_; i++) {
    if (btag_deep_[corrected_jet[i].Idx()] > deepcsv_cut_tight) {
      bjets.push_back(std::make_tuple(corrected_jet[i], i));
    } else {
      softjets.push_back(corrected_jet[i]);
    }
  }
  if (softjets.empty()) {
    return;
  }
  for (auto it : bjets) {
    auto appo = std::get<0>(it);
    auto i = std::get<1>(it);
    vector<Jet>::iterator best = std::min_element(\
       softjets.begin(), softjets.end(), [&appo](const Jet& a, const Jet& b) {
         return appo.DeltaR(a) < appo.DeltaR(b);
       });
    if (best != softjets.end() && best->DeltaR(appo) > soft_jet_distance) { continue; }
    
    if (debug) {
      cout << "Correcting for fsr. Added something.\n" <<               \
        "PtBefore: " << appo.Pt() << "\tPt after: " << (appo + *best).Pt() << \
        "\tEta before: " << appo.Eta() << "\tEta after: " << (appo + *best).Eta() << endl;
      cout << "Best candidate had pt: " << best->Pt() << " R distance: " \
           << appo.DeltaR(*best) << endl;
    }
    Float_t minimum = leptonic ? pt_cut_lep[pt_cut_lep.size() - 1] : \
      pt_cut_had[pt_cut_had.size() - 1];
    if ((appo + *best).Pt() > minimum) {
      appo += *best;
      corrected_jet[i].SetPtEtaPhiM(appo.Pt(), appo.Eta(), appo.Phi(), appo.M());
    }
  }
  return;
}


void get_chain_files(TChain* chain) {
  {% for file in filenames %}
    chain->Add("{{ basedir }}{{ file }}");{% endfor %}
}


int main(int argc, char* argv[]) {
  TH1::SetDefaultSumw2();  // proper treatment of errors when scaling histograms
  if (argc != 2) {
    cerr << "\033[0;31mPlease give the name of the file where you want to" <<
      "put the output as an argument. Aborting.\033[0m" << endl;
    return -1;
  }
  TChain chain("Events");
  get_chain_files(&chain);
  if (chain.IsZombie()) {
    cerr << "Error opening input file! Aborting." << endl;
    return -2;
  }
  TFile output(argv[1], "create");
  if (output.IsZombie()) {
    cerr << "Error opening output file " << argv[1] << ". Make sure that "
      "the file does not exist. Aborting." << endl;
    return -3;
  }
  TTree output_tree("output_tree", "Histograms and data for H->bb decay");
  DataContainer container;
  container.SetTreeBranches(&chain);
  container.CreateTree(&output_tree);
  {% if bkg %}
  TH1F mass_histo_chromo("mass_histo_chromo",                           \
                         "Invariant mass of bb jets (NL)", bins, 0, highx);
  TH1F mass_histo_lepton("mass_histo_lepton",                           \
                         "Invariant mass of bb jets (L)", bins, 0, highx);
  std::vector<TH1F*> histos;
  histos.push_back(&mass_histo_chromo);
  histos.push_back(&mass_histo_lepton);
  {% else %}
  TH1F mass_histo_chromo_0_match("mass_histo_chromo_0_match", \
                      "Invariant mass of bb jets", bins, 0, highx);
  TH1F mass_histo_lepton_0_match("mass_histo_lepton_0_match", \
                            "Invariant mass of bb jets", bins, 0, highx);
  TH1F mass_histo_chromo_1_match("mass_histo_chromo_1_match",                           \
                         "Invariant mass of bb jets", bins, 0, highx);
  TH1F mass_histo_lepton_1_match("mass_histo_lepton_1_match",                           \
                            "Invariant mass of bb jets", bins, 0, highx);
  TH1F mass_histo_chromo_2_match("mass_histo_chromo_2_match",           \
                                 "Invariant mass of bb jets", bins, 0, highx);
  TH1F mass_histo_lepton_2_match("mass_histo_lepton_2_match",           \
                         "Invariant mass of bb jets", bins, 0, highx);
  std::vector<TH1F*> histos;
  histos.push_back(&mass_histo_chromo_0_match);
  histos.push_back(&mass_histo_chromo_1_match);
  histos.push_back(&mass_histo_chromo_2_match);
  histos.push_back(&mass_histo_lepton_0_match);
  histos.push_back(&mass_histo_lepton_1_match);
  histos.push_back(&mass_histo_lepton_2_match);
  {% endif %}
  TH1F pt_spectrum_chromo("pt_spectrum_chromo",                         \
                          "Pt spectrum for chromo events", bins, 0, highx);
  TH1F pt_spectrum_lepton("pt_spectrum_lepton", \
                          "Pt spectrum for lepton events", bins, 0, highx);
  TH1F reg_res_chromo("reg_res_chromo", "RegRes for non lepton events", \
                      bins, 0, 1);
  TH1F reg_res_lepton("reg_res_lepton", "RegRes for lepton events",     \
                      bins, 0, 1);
  histos.push_back(&pt_spectrum_chromo);
  histos.push_back(&pt_spectrum_lepton);
  histos.push_back(&reg_res_chromo);
  histos.push_back(&reg_res_lepton);


  container.fill_histogram(&chain, histos, &output_tree);
  output.cd();
  {% if bkg %}

  {% else %}
  mass_histo_chromo_0_match.SetLineColor(kPink);
  mass_histo_chromo_1_match.SetLineColor(kBlue);
  mass_histo_chromo_2_match.SetLineColor(kGreen);
  mass_histo_lepton_0_match.SetLineColor(kRed);
  mass_histo_lepton_1_match.SetLineColor(kOrange);
  mass_histo_lepton_2_match.SetLineColor(kYellow);
  TH1F mass_histo_sum(mass_histo_chromo_0_match);
  mass_histo_sum.Add(&mass_histo_chromo_1_match, 1.);
  mass_histo_sum.Add(&mass_histo_chromo_2_match, 1.);
  mass_histo_sum.Add(&mass_histo_lepton_0_match, 1.);
  mass_histo_sum.Add(&mass_histo_lepton_1_match, 1.);
  mass_histo_sum.Add(&mass_histo_lepton_2_match, 1.);
  mass_histo_sum.SetLineColor(kBlack);
  cout << "Entries in total histo: " <<        \
    mass_histo_sum.GetEntries() << endl;
  {% endif %}
  for (auto it : histos) {
    it->Write();
  }
  {% if not bkg %}
  mass_histo_sum.Write();
  {% endif %}
  
  output_tree.Write();
  return 0;
}
